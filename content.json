{"pages":[{"title":"Hello World!","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world.html"},{"title":"金咕咕doinb","text":"啦啦啦，啦啦啦，我是卖报的小行家！","link":"/%E9%87%91%E5%92%95%E5%92%95doinb.html"}],"posts":[{"title":"","text":"##主要说明Java和JS的不同点 1.JavaScript的变量类型：数值类型： number 字符串类型： string 对象类型： object 布尔类型： boolean 函数类型： function 2.JavaScript里特殊的值：undefined: 未定义，所有js变量未赋予初始值的时候都说undefined null 空值 NAN Not a number。非数字 3.关系运算：==： 只要值相等就行了 ===： 全等于才行（数据类型也要相等） 4.逻辑运算：1.在JS中，所有的变量都可以作为一个boolean类型的变量去使用 0,null,undefined,&quot;&quot;(空串)默认都是false 2.&amp;&amp; 且运算 有两种情况： 第一种：全为真，返回最后一个表达式的值 第二种：为假时，返回第一个为假的表达式的值 3.|| 或运算 全为假，返回最后一个表达式的值 为真时，返回第一个为真的表达式的值 5.数组：定义： var arr = []; 注意：数组能自动扩容,数组里类型任意，数组长度为赋值的最大下标 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; var arr = []; arr[0] = 12; arr[2] = &quot;abc&quot;; alert(arr.length); for(var i = 0;i&lt;arr.length;i++){ alert(arr[i]); }&lt;/script&gt; 6.函数：第一种定义方式： function 函数名(形参列表){ 函数体 } 在 JavaScript 语言中，如何定义带有返回值的函数？ 只需要在函数体内直接使用 return 语句返回值即可 第二章定义方式： var 函数名 = function(形参列表){ 函数体 } 注：在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义 7.函数的 arguments 隐形参数（只在 function 函数内）在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。 隐形参数特别像 java 基础的可变长参数一样。 public void fun(Object ...args); 可变长参数其他是一个数组。 12345678910111213141516171819202122 &lt;script type=&quot;text/javascript&quot;&gt; function fun(a) { alert( arguments.length );//可看参数个数 alert(&quot;a = &quot; + a); for (var i = 0; i &lt; arguments.length; i++){ alert( arguments[i] ); } alert(&quot;无参函数 fun()&quot;); } // fun(1,&quot;ad&quot;,true); // 需求：要求 编写 一个函数。用于计算所有参数相加的和并返回 function sum(num1,num2) { var result = 0; for (var i = 0; i &lt; arguments.length; i++) { if (typeof(arguments[i]) == &quot;number&quot;) { result += arguments[i]; } } return result; } alert( sum(1,2,3,4,&quot;abc&quot;,5,6,7,8,9) );&lt;/script&gt; 8.JS 中的自定义对象（扩展内容）对象的定义： var 变量名 = new Object(); // 对象实例（空对象） 变量名.属性名 = 值; // 定义一个属性 变量名.函数名 = function(){} // 定义一个函数 对象的访问： 变量名.属性 / 函数名() 1234567891011121314// 对象的定义：// var 变量名 = new Object(); // 对象实例（空对象）// 变量名.属性名 = 值; // 定义一个属性// 变量名.函数名 = function(){} // 定义一个函数var obj = new Object();obj.name = &quot;华仔&quot;;obj.age = 18;obj.fun = function () {alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.age);}// 对象的访问：// 变量名.属性 / 函数名();// alert( obj.age );obj.fun(); 9.{}花括号形式的自定义对象 对象的定义： var 变量名 = { // 空对象 属性名：值, // 定义一个属性 属性名：值, // 定义一个属性 函数名：function(){} // 定义一个函数 }; 对象的访问： 变量名.属性 / 函数名() 123456789var obj = {name:&quot;国哥&quot;,age:18,fun : function () { alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.age); }};alert(obj.name);obj.fun(); 10.js 中的事件用的事件： onload 加载完成事件： 页面加载完成之后，常用于做页面 js 代码初始化操作 onclick 单击事件： 常用于按钮的点击响应操作。 onblur 失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。 onchange 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作 onsubmit 表单提交事件： 常用于表单提交前，验证所有表单项是否合法。 事件的注册又分为静态注册和动态注册两种： 什么是事件的注册（绑定）？ 其实就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。 静态注册事件：通过 html 标签的事件属性直接赋于事件响应后的代码，这种方式我们叫静态注册。 动态注册事件：是指先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 = function(){} 这种形式赋于事件，响应后的代码，叫动态注册。 动态注册基本步骤： 1、获取标签对象 2、标签对象.事件名 = fucntion(){} 12345678910111213141516171819202122232425262728// onclick事件的动态注册与静态注册 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function onclickFun(){ alert(&quot;静态注册onclick事件&quot;); } window.onload = function () { // 1.获取标签对象 let btnObj = document.getElementById(&quot;btn1&quot;); // 通过标签对象.事件名 = function(){} btnObj.onclick = function () { alert(&quot;动态注册onclick事件&quot;); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 静态注册onclick事件 --&gt; &lt;button onclick=&quot;onclickFun();&quot;&gt;按钮1&lt;/button&gt; &lt;!-- 动态注册 --&gt; &lt;button id=&quot;btn1&quot;&gt;按钮2&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 11.DOM 模11.1. Document对象Document 对象的理解： 第一点：Document 它管理了所有的 HTML 文档内容。 第二点：document 它是一种树结构的文档。有层级关系。 第三点：它让我们把所有的标签 都 对象化 第四点：我们可以通过 document 访问所有的标签对象 11.2. Document 对象中的方法介绍document.getElementById(elementId) 通过标签的 id 属性查找标签 dom 对象，elementId 是标签的 id 属性值 document.getElementsByName(elementName) 通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值 document.getElementsByTagName(tagname) 通过标签名查找标签 dom 对象。tagname 是标签名 document.createElement( tagName) 方法，通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名 注： document 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName 以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象。 12345678910111213141516171819202122 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () { let divObj = document.createElement(&quot;div&quot;); // 在内存里 &lt;div&gt; &lt;/div&gt; let text = document.createTextNode(&quot;这是div里的文本内容&quot;); // 创建一个文本节点对象 divObj.appendChild(text); // &lt;div&gt;这是div里的文本内容&lt;/div&gt; document.body.appendChild(divObj); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 11.3. 节点的常用属性和方法方法： 通过具体的元素节点调用 getElementsByTagName() 方法，获取当前节点的指定标签名孩子节点 appendChild( oChildNode ) 方法，可以添加一个子节点，oChildNode 属性： childNodes 属性，获取当前节点的所有子节点 firstChild 属性，获取当前节点的第一个子节点 lastChild 属性，获取当前节点的最后一个子节点 parentNode 属性，获取当前节点的父节点 nextSibling 属性，获取当前节点的下一个节点 previousSibling 属性，获取当前节点的上一个节点 className 用于获取或设置标签的 class 属性值 innerHTML 属性，表示获取/设置起始标签和结束标签中的内容 innerText 属性，表示获取/设置起始标签和结束标签中的文本","link":"/2021/11/03/JavaScript/"},{"title":"","text":"表单的显示 用户注册 用户名称： 密码： 确认密码： 性别： 男 女 兴趣爱好： Java C python 国籍： --请选择国际-- 中国 美国 小日本 自我评价： 默认值","link":"/2021/11/02/Html%20Learning/"},{"title":"Map","text":"代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.junit.Test;import java.util.*;/** * @author Jianz * @version 1.0 * @Description * @Email jianz8153.gmail.com * @Date 2021/10/17 18:45 */public class SetTest { @Test public void test() { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); //添加 map.put(1, &quot;jianz&quot;); map.put(2, &quot;doinb&quot;); // 第二种添加方式 ： map.putAll(map1); //修改 map.put(1, &quot;ZJ&quot;); //移除 map.remove(2); //clear() : 清空 map.clear(); //get(key) : 获取某个value // boolean containsValue(value), boolean containsKey(key) //...其他一堆方法 //遍历/* List可以使用iterator迭代器来遍历元素，但map不行 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(&quot;1&quot;); arrayList.add(&quot;3&quot;); arrayList.add(&quot;2&quot;); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } */ //map中的遍历 ： 调用keySet()方法，然后调value Set&lt;Integer&gt; key = map.keySet(); for (Integer integer : key) { System.out.println(map.get(integer)); } //直接遍历所有的value集 : values() for (String value : map.values()) { System.out.println(value); } //遍历所有的key-value entrySet() Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = set.iterator(); while(iterator.hasNext()){ Map.Entry entry = (Map.Entry) iterator.next(); System.out.println(entry.getKey() + &quot;---&quot; + entry.getValue()); } System.out.println(map); }}","link":"/2021/10/18/Map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E9%81%8D%E5%8E%86/"},{"title":"Java多态的相关知识","text":"多态 多态的定义：一个对象有多种形态。 代码展示 123456789101112131415161718192021222324252627282930package com.jianz;public class Main { public static void main(String[] args) { Person man = new student(); //多态的应用 man.eat(); student p = (student) man; //向下转型 p.age = 18; System.out.println(p.age); p.eat(); } }class Person { public void eat(){ System.out.println(&quot;人吃饭&quot;); }}class student extends Person{ int age; public void eat(){ //方法的重写 System.out.println(&quot;学生要多吃点长身体&quot;); }} 多态的总结 成长的速度一定要快过父母老去的速度呀！","link":"/2021/09/27/Java%E5%A4%9A%E6%80%81%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"MySQL基础知识","text":"一.MySQL数据类型常用类型1.最常用的一些类型：整数：int 浮点数：double 日期：date、 datetime、 timestamp 字符串：varchar (省空间) 、 char（效率高） 大数据：blob 、 text 2.其他一些类型: 整数类型： tinyInt 很小的整数 smallint 小的整数 mediumint 中等大小的整数 *int(integer) 普通大小的整数 bigint 大整数 小数类型： float（m,d） 单精度浮点数 *double（m,d） 双精度浮点数 decimal（m,d） 压缩严格的定点数（小数的精确运算）浪费空间 日期类型： year YYYY 1901~2155 time HH:MM:SS -838:59:59~838:59:59 *date YYYY-MM-DD 1000-01-01~9999-12-3 *datetime YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59 *timestamp YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC 文本、二进制类型： *CHAR(M)(定长字符串) M为0~255之间的整数 *VARCHAR(M)（变长字符串） M为0~65535之间的整数 TINYBLOB 允许长度0~255字节 *BLOB 允许长度0~65535字节 MEDIUMBLOB 允许长度0~167772150字节 LONGBLOB 允许长度0~4294967295字节 TINYTEXT 允许长度0~255字节 *TEXT 允许长度0~65535字节 MEDIUMTEXT 允许长度0~167772150字节 LONGTEXT 允许长度0~4294967295字节 VARBINARY(M) 允许长度0~M个字节的变长字节字符串 BINARY(M) 允许长度0~M个字节的定长字节字符串 二.数据处理之查询1.基本 SELECT 语句12SELECT *|{[DISTINCT] column|expression [alias],...}FROM table; • SELECT 标识选择哪些列。• FROM 标识从哪个表中选择。 2.选择全部列12SELECT *FROM departments; 3.选择特定的列12SELECT department_id, location_idFROM departments; 注 意: SQL 语言大小写不敏感。 SQL 可以写在一行或者多行 关键字不能被缩写也不能分行 各子句一般要分行写。 使用缩进提高语句的可读性。 4.列的别名12345使用‘AS’或者‘ ’来表示别名SELECT last_name AS name, commission_pct commFROM employees;SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;FROM employees; 5.字符串• 字符串可以是 SELECT 列表中的一个字符,数字,日期。 • 日期和字符只能在单引号中出现。 • 每当返回一行时，字符串被输出一次。 三：过滤1.使用WHERE 子句（将不满足条件的行过滤掉）1234通式：SELECT *|{[DISTINCT] column|expression [alias],...}FROM table[WHERE condition(s)]; 2.比较运算 操作符 含义 = 等于 (不是 ==) &gt; 大于 &gt;= 大于、等于 &lt; 小于 &lt;= 小于、等于 &lt;&gt; 不等于 (也可以是 !=) 123SELECT last_name, salaryFROM employeesWHERE salary &lt;= 3000; 3.其他比较运算 操作数 含义 BETWEEN...AND 在两个值之间 (包含边界) IN(set) 等于值列表中的一个 LIKE 模糊查询 IS NULL 空值 123456789101112131415IN:SELECT employee_id, last_name, salary, manager_idFROM employeesWHERE manager_id IN (100, 101, 201);•使用 LIKE 运算选择类似的值• 选择条件可以包含字符或数字:– % 代表零个或多个字符(任意个字符)。– _ 代表一个字符。LIKE：SELECT first_nameFROM employeesWHERE first_name LIKE '_o%';使用 IS (NOT) NULL 判断空值。 4.逻辑运算 操作符 含义 AND 逻辑并 OR 逻辑或 NOT 逻辑否 5.ORDER BY子句 使用 ORDER BY 子句排序 – ASC（ascend）: 升序 – DESC（descend）: 降序 • ORDER BY 子句在SELECT语句的结尾。 1234多个列排序:SELECT last_name, department_id, salaryFROM employeesORDER BY department_id, salary DESC; 四：分组函数 组函数类型： • AVG() • COUNT() • MAX() • MIN() • SUM() 1.分组数据：GROUP BY 子句语法123SELECT department_id, AVG(salary)FROM employeesGROUP BY department_id ; 2.非法使用组函数• 不能在 WHERE 子句中使用组函数。 • 可以在 HAVING 子句中使用组函数。 12345错误写法：SELECT department_id, AVG(salary)FROM employeesWHERE AVG(salary) &gt; 8000GROUP BY department_id; 3.过滤分组： HAVING 子句1234SELECT department_id, MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary)&gt;10000; 五：JOIN ON连接12345678910111213141516171819202122232425262728293031323334353637383940414243#一）等值连接#案例1.查询员工名、部门名SELECT last_name,department_nameFROM departments dJOIN employees eON e.`department_id` = d.`department_id`;#二）非等值连接#查询员工的工资级别SELECT salary,grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;#三）自连接#查询员工的名字、上级的名字SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e, employees mWHERE m.employee_id = e.manager_id; #四）外连接 #左外连接SELECT d.*,e.employee_idFROM departments dLEFT OUTER JOIN employees eON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;#右外连接SELECT d.*,e.employee_idFROM employees eRIGHT OUTER JOIN departments dON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;#交叉连接SELECT b.*,bo.*FROM beauty bCROSS JOIN boys bo; 六：常见函数字符控制函数： CONCAT('Hello', 'World') SUBSTR('HelloWorld',1,5) LENGTH('HelloWorld') INSTR('HelloWorld', 'W') LPAD(salary,10,'*') RPAD(salary, 10, '*') TRIM('H' FROM 'HelloWorld') REPLACE('abcd','b','m') 日期函数: now() CASE 表达式: CASE expr WHEN comparison_expr1 THEN return_expr1 [WHEN comparison_expr2 THEN return_expr2 WHEN comparison_exprn THEN return_exprn ELSE else_expr] END 七：数据处理之增删改增： INSERT INTO table [(column [, column...])] VALUES (value [, value...]); 改： UPDATE table SET column = value [, column = value, ...] [WHERE condition]; 删： DELETE FROM table [WHERE condition]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /* 对于hire_date这种为datetime类型的字段可以用now()函数来直接填写当前的时间 */-- INSERT:# 隐式方式：在列名表中省略该列的值INSERT INTO departments(department_name )VALUES ('Pur');# 显示方法：在VALUES子句中指定空值INSERT INTO departments(department_name,location_id,manager_id)VALUES ('Fin',NULL,NULL);#从其它表中拷贝数据-- 第一种INSERT INTO emp2 #emp2：新建的表，与employees表中的字段完全相同 SELECT * FROM employeesWHERE department_id = 90;-- 第二种INSERT INTO sales_reps(id, name, salary, commission_pct)SELECT employee_id, last_name, salary, commission_pctFROM employeesWHERE job_id LIKE '%REP%';#解释：从employees表中选中一些字段导入sales——reps表中.-- UPDATE/*此为修改主键的值，只能在WHERE中选中修改之前的时候主键的值，然后改为想修改成的值UPDATE departmentsSET department_id = 280WHERE department_id = 274;*/UPDATE employeesSET department_id = 70WHERE employee_id = 113;#可以一次更新多条数据-- DELETE/*删除刚创建的元素DELETE FROM departmentsWHERE department_name = 'Pur' AND department_id = 272; */ 八：子查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129SELECT *FROM employeesWHERE salary&gt;( SELECT salary FROM employees WHERE last_name = 'Abel');SELECT last_name,job_id,salaryFROM employeesWHERE job_id = ( SELECT job_id FROM employees WHERE employee_id = 141)AND salary &gt;( SELECT salary FROM employees WHERE employee_id = 143); SELECT last_name,job_id,salary FROM employees WHERE salary = ( SELECT MIN(salary) FROM employees );SELECT DISTINCT department_idFROM departmentsWHERE location_id = 1500; SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700)ORDER BY department_id ASC;SELECT last_name,department_idFROM employeesWHERE department_id &lt;&gt; ALL( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700))ORDER BY department_id ASC;SELECT department_name,e.employee_id,d.department_idFROM departments dJOIN employees eON e.department_id = d.department_idWHERE e.employee_id = 102;#FROM后面SELECT AVG(salary),department_name,e.department_idFROM employees eJOIN departments dON e.department_id = d.department_idGROUP BY department_id;SELECT AVG(salary),department_idFROM employeesGROUP BY department_idSELECT *FROM job_grades;SELECT avg_dep.*,jg.grade_levelFROM( SELECT AVG(salary) avgs,department_name,e.department_id FROM employees e JOIN departments d ON e.department_id = d.department_id GROUP BY department_id)avg_depJOIN job_grades jgON avg_dep.avgs BETWEEN lowest_sal AND highest_sal;#查询有员工的部门名 用exist-- 方式一：使用join#注意点：注意：distinct关键字只能放在所有字段前面，不能在某个字段之后。SELECT DISTINCT d.department_idFROM departments d JOIN employees eON e.department_id = d.department_id#WHERE e.department_id IS NULL;SELECT department_nameFROM departments dWHERE d.department_id = ANY( SELECT DISTINCT d.department_id FROM departments d JOIN employees e ON e.department_id = d.department_id #WHERE e.department_id IS NULL);-- 方式二： 使用EXISTSSELECT department_nameFROM departments d WHERE EXISTS( SELECT * FROM employees e WHERE d.department_id = e.department_id );-- 方式三： 用INSELECT department_nameFROM departments dWHERE d.department_id IN( SELECT department_id FROM employees e WHERE e.department_id = d.department_id);-- -------------------------------------------------------------------------------------------------- 习题#1. 查询和Zlotkey相同部门的员工姓名和工资SELECT last_name,salaryFROM employees eWHERE e.department_id =( SELECT department_id FROM employees WHERE last_name = 'Zlotkey'); 九：创建数据库和表1.创建数据库 创建一个保存员工信息的数据库 – create database employees;  相关其他命令 – show databases;查看当前所有数据库 – use employees;“使用”一个数据库，使其作为当前数据库 删除数据库 DROP DATABASE IF EXISTS 数据库名; 2.创建表CREATE TABLE [schema.]table (column datatype [DEFAULT expr][, ...]); 3.使用子查询创建表123create table emp1 as select * from employees;create table emp2 as select * from employees where 1=2;--创建的emp2是空表。 4.修改表ALTER TABLE 语句： 123456789101112131415ADD:ALTER TABLE dept80 ADD job_id varchar(15);MODIFY:ALTER TABLE dept80MODIFY (last_name VARCHAR(30));DROP: ALTER TABLE dept80DROP COLUMN job_id;CHANGE重命名：ALTER TABLE dept80CHANGE department_name dept_name varchar(15); 5.删除表DROP TABLE dept80; 6.清空表TRUNCATE TABLE detail_dept; 十：常见约束与分页查询1.常见约束1234567891011121314151617181920212223242526272829303132333435363738 CREATE TABLE stuinfo( id INT PRIMARY KEY, #主键 `NAME` VARCHAR(20) NOT NULL UNIQUE, #非空且唯一 gender CHAR(1) CHECK(gender='男' OR gender='女'), #检查 seat INT UNIQUE, #唯一 age INT DEFAULT 18, #默认 majorid INT REFERENCES major(id) #外键);CREATE TABLE major( id INT PRIMARY KEY, majorName VARCHAR(20));SHOW INDEX FROM stuinfo;DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuName VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT PK PRIMARY KEY(id), #主键 CONSTRAINT up UNIQUE(seat), #唯一 CONSTRAINT ck CHECK(gender = '男' OR gender = '女') #检查 )/* 位置 支持的约束类型 是否可以起约束名列级约束： 列的后面 语法都支持，但外键没有效果 不可以表级约束： 所有列的下面 默认和非空不支持，其他支持 可以（主键没有效果）*/ 2.分页查询1234567891011121314151617181920212223242526272829303132/* 语法： select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; offset要显示条目的起始索引（**起始索引从0开始） size 要显示的条目个数 */ SELECT * FROM employees LIMIT 0,5; #OR: SELECT * FROM employees LIMIT 5; #案例3：有奖金的员工信息，并且工资较高的前10名显示出来 SELECT * FROM employees WHERE commission_pct IS NOT NULL ORDER BY salary DESC LIMIT 10;","link":"/2021/10/20/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"多线程","text":"多线程(Thread)的两种基础创建手段1.通过extends Thread类改写run方法来创建,并用synchronized修饰方法来解决线程安全问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * @author Jianz * @version 1.0 * @Description * @Email jianz8153.gmail.com * @Date: 2021/10/6 23:02 */class ticketShop{ private static int ticket = 100; public synchronized static void sell(){ if(ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + ticket); ticket--; } } public static int getTicket() { return ticket; }}/** * @author Jianz */public class extendMethod extends Thread { @Override public void run(){ while (ticketShop.getTicket() &gt; 0) { ticketShop.sell(); } } }class TestMethod { public static void main(String[] args) { extendMethod method1 = new extendMethod(); extendMethod method2 = new extendMethod(); extendMethod method3 = new extendMethod(); method1.setName(&quot;线程1&quot;); method2.setName(&quot;线程2&quot;); method3.setName(&quot;线程3&quot;); method1.start(); method2.start(); method3.start(); }} 2.通过调用runnable接口来实现多线程,并通过synchronized()代码块解决线程安全问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * @author Jianz * @version 1.0 * @Description * @Email jianz8153.gmail.com * @Date: 2021/10/6 23:02 */class ticketShop{ private static int ticket = 100; public static void sell() throws InterruptedException { if(ticket &gt; 0) { Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot;: &quot; + ticket); ticket--; } } public static int getTicket() { return ticket; }}/** * @author Jianz */public class extendMethod implements Runnable { @Override public void run(){ while (ticketShop.getTicket() &gt; 0) { synchronized(this){ try { ticketShop.sell(); } catch (InterruptedException e) { e.printStackTrace(); } } } } }class TestMethod { public static void main(String[] args) { extendMethod method = new extendMethod(); /** * 通过创造Thread类的对象来实现多线程 */ Thread T1 = new Thread(method); Thread T2 = new Thread(method); Thread T3 = new Thread(method); T1.setName(&quot;线程一&quot;); T2.setName(&quot;线程二&quot;); T3.setName(&quot;线程三&quot;); T1.start(); T2.start(); T3.start(); }} 线程的调度1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。 Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量： static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。 static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。 static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。 Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。 JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。 3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。 线程的生命周期 解决线程安全问题方式三：Lock锁与synchronized异同对比相同点：都能解决线程安全问题 不同点：synchronized机制再执行完相应的同步代码以后，自动的释放同步检测器 Lock需要手动的启动同步（Lock()）,同时结束同步也需要手动的实现（unlock()） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author Jianz * @version 1.0 * @Description * @Email jianz8153.gmail.com * @Date: 2021/10/6 23:02 */class Window implements Runnable { private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { //2.调用锁定方法lock() lock.lock(); if (ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;: &quot; + ticket); ticket--; } else { break; } } finally { //3.调用解锁方法：unlock() lock.unlock(); } } }}public class lockTest{ public static void main(String[] args) { Window window = new Window(); Thread T1 = new Thread(window); Thread T2 = new Thread(window); Thread T3 = new Thread(window); T1.setName(&quot;线程1&quot;); T2.setName(&quot;线程2&quot;); T3.setName(&quot;线程3&quot;); T1.start(); T2.start(); T3.start(); }} 线程的同步例题例：银行有一个账户。 有两个储户分别向同一个账户存3000元,每次存1000,存3次。每次存完打印账户余额。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154class Account { private static int account = 0; public synchronized static void deposit() { account += 1000; System.out.println(Thread.currentThread().getName() + &quot; 存钱1000余额为 &quot; + account); }}class Window implements Runnable { @Override public void run() { for (int i = 0; i &lt; 3; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } Account.deposit(); } } }public class practice1 { public static void main(String[] args) { Window window = new Window(); Thread T1 = new Thread(window); Thread T2 = new Thread(window); T1.setName(&quot;储户一&quot;); T2.setName(&quot;储户二&quot;); T1.start(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } T2.start(); }}``` ### 线程的通信经典例题：生产者/消费者问题```java/** * @author Jianz * @version 1.0 * @Description * @Email jianz8153.gmail.com * @Date: 2021/10/6 23:02 */class Clerk { private static int product = 0; /** * 注意：同步监视器此时是Clerk的对象。本案例中只new了一个Clerk的对象clerk，所以消费者和生产者的同步监视器一样。 */ public synchronized void produce() { if (product &lt; 20) { product++; System.out.println(Thread.currentThread().getName() + &quot;正在生产第 &quot; + product + &quot; 个产品&quot;); notify(); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void consume() { if (product &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;正在消费第 &quot; + product + &quot; 个产品&quot;); product--; notify(); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } }else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Producer extends Thread { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + &quot;开始生产&quot;); while(true) { clerk.produce(); } }}class Consumer extends Thread { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + &quot;开始消费&quot;); while (true) { clerk.consume(); } }}public class practice1 { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer producer = new Producer(clerk); Consumer consumer = new Consumer(clerk); producer.setName(&quot;生产者&quot;); consumer.setName(&quot;消费者&quot;); producer.start(); consumer.start(); }}","link":"/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"接口，继承，多态的简单应用","text":"上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @description 继承，多态，接口的应用 * @author 张健 */public class Main { public static void main(String[] args) { Flyable flyAbject = new Bullet(); flyAbject.fly(); flyAbject.stop(); if (flyAbject instanceof Bullet) { System.out.println(&quot;Yes&quot;); } Bullet bullet = (Bullet) flyAbject; System.out.println(bullet.getWeight()); System.out.println(new Plane().getWeight()); new Plane().fly(); new Plane().stop(); }}class Bullet implements Flyable { public Bullet() { } private int weight = 100; @Override public void fly() { System.out.println(&quot;弹从枪出,速度&quot; + Flyable.MAX_SPEED); } @Override public void stop() { System.out.println(&quot;一枪毙命&quot;); } public void setWeight(int weight) { this.weight = weight; } public int getWeight() { return weight; }}class Plane extends Bullet implements Flyable { public Plane() { this.setWeight(10000); } @Override public void fly() { System.out.println(&quot;全体起立，起飞&quot;); } @Override public void stop() { System.out.println(&quot;飞机降落&quot;); }}interface Flyable { int MAX_SPEED = 5000; int MIN_SPEED = 100; @SuppressWarnings(&quot;AlibabaAbstractMethodOrInterfaceMethodMustUseJavadoc&quot;) void fly(); @SuppressWarnings(&quot;AlibabaAbstractMethodOrInterfaceMethodMustUseJavadoc&quot;) void stop();} Over 成长的速度一定要快过父母老去的速度呀！","link":"/2021/10/01/%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"}],"tags":[],"categories":[]}